"""
Enhanced community endpoints with comprehensive media support, moderation,
fact-checking, and educational content creation features.
"""
import logging
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
from fastapi import APIRouter, HTTPException, Depends, Query, UploadFile, File, Form, status, BackgroundTasks
from fastapi.responses import StreamingResponse

from app.models.enhanced_community_schemas import (
    EnhancedCommunityPost, CommunityPostInDB, PostComment, UserInteraction,
    CommunityReport, CommunityModerationQueue, CommunityDashboard,
    FactCheckRequest, PostCreateRequest, PostUpdateRequest, PostSearchRequest,
    CommunityNotification, PostType, PostStatus, ModerationAction,
    InteractionType, VerificationStatus, EnhancedMediaUpload
)
from app.models.enhanced_learning_schemas import MisinformationCategory
from app.auth.firebase import get_current_user, require_roles
from app.services.firestore_service import firestore_service
from app.services.cloudinary_service import cloudinary_service
from app.services.gemini_service import gemini_service
from app.core.config import settings

logger = logging.getLogger(__name__)
router = APIRouter()


# Community Post Management

@router.post("/posts", response_model=CommunityPostInDB, status_code=status.HTTP_201_CREATED)
async def create_community_post(
    post_data: PostCreateRequest,
    background_tasks: BackgroundTasks,
    current_user: dict = Depends(get_current_user)
):
    """
    Create a new community post with media support.
    """
    try:
        user_id = current_user.get("uid")
        user_name = current_user.get("name", "Anonymous")
        
        # Create post object
        post = CommunityPostInDB(
            id=None,  # Will be generated by Firestore
            author_id=user_id,
            title=post_data.title,
            content=post_data.content,
            post_type=post_data.post_type,
            category=post_data.category,
            misinformation_category=post_data.misinformation_category,
            is_educational=post_data.is_educational,
            requires_fact_check=post_data.requires_fact_check,
            media_uploads=post_data.media_uploads,
            external_links=post_data.external_links,
            tags=post_data.tags,
            visibility=post_data.visibility,
            allow_comments=post_data.allow_comments,
            collaborative_editing=post_data.collaborative_editing,
            created_at=datetime.utcnow(),
            status=PostStatus.PUBLISHED if not post_data.requires_fact_check else PostStatus.UNDER_REVIEW
        )
        
        # Calculate reading time
        word_count = len(post_data.content.split())
        post.reading_time_minutes = max(1, word_count // 200)  # Assume 200 WPM reading speed
        
        # Store post in database
        post_id = await firestore_service.create_enhanced_community_post(post.dict())
        post.id = post_id
        
        # Background tasks
        if post_data.requires_fact_check:
            background_tasks.add_task(initiate_fact_check, post_id, user_id)
        
        if post_data.is_educational:
            background_tasks.add_task(analyze_educational_value, post_id)
        
        # Auto-detect potential misinformation
        if post_data.misinformation_category:
            background_tasks.add_task(analyze_misinformation_content, post_id, post_data.content)
        
        logger.info(f"Community post created: {post_id} by user {user_id}")
        return post
        
    except Exception as e:
        logger.error(f"Error creating community post: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to create community post")


@router.get("/posts", response_model=List[CommunityPostInDB])
async def get_community_posts(
    post_type: Optional[PostType] = Query(None, description="Filter by post type"),
    category: Optional[str] = Query(None, description="Filter by category"),
    misinformation_category: Optional[MisinformationCategory] = Query(None, description="Filter by misinformation category"),
    tags: Optional[List[str]] = Query(None, description="Filter by tags"),
    verified_only: Optional[bool] = Query(False, description="Show only verified posts"),
    educational_only: Optional[bool] = Query(False, description="Show only educational posts"),
    sort_by: str = Query("recent", description="Sort order"),
    page: int = Query(1, ge=1, description="Page number"),
    limit: int = Query(20, ge=1, le=100, description="Results per page"),
    current_user: Optional[dict] = Depends(get_current_user)
):
    """
    Get community posts with advanced filtering and pagination.
    """
    try:
        user_id = current_user.get("uid") if current_user else None
        
        # Build search criteria
        search_criteria = {
            "post_type": post_type.value if post_type else None,
            "category": category,
            "misinformation_category": misinformation_category.value if misinformation_category else None,
            "tags": tags,
            "verified_only": verified_only,
            "educational_only": educational_only,
            "sort_by": sort_by,
            "page": page,
            "limit": limit,
            "status": "published"  # Only show published posts
        }
        
        posts = await firestore_service.search_community_posts(search_criteria, user_id)
        
        # Add user interaction data if authenticated
        if user_id:
            for post in posts:
                interactions = await firestore_service.get_user_post_interactions(user_id, post["id"])
                post["is_liked"] = any(i.get("interaction_type") == "like" for i in interactions)
                post["is_bookmarked"] = any(i.get("interaction_type") == "bookmark" for i in interactions)
        
        return [CommunityPostInDB(**post) for post in posts]
        
    except Exception as e:
        logger.error(f"Error getting community posts: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to get community posts")


@router.get("/posts/{post_id}", response_model=CommunityPostInDB)
async def get_community_post(
    post_id: str,
    current_user: Optional[dict] = Depends(get_current_user)
):
    """
    Get a specific community post by ID.
    """
    try:
        post = await firestore_service.get_enhanced_community_post(post_id)
        if not post:
            raise HTTPException(status_code=404, detail="Post not found")
        
        user_id = current_user.get("uid") if current_user else None
        
        # Increment view count (if not the author viewing)
        if user_id and user_id != post.get("author_id"):
            await firestore_service.increment_post_views(post_id)
        
        # Add user interaction data
        if user_id:
            interactions = await firestore_service.get_user_post_interactions(user_id, post_id)
            post["is_liked"] = any(i.get("interaction_type") == "like" for i in interactions)
            post["is_bookmarked"] = any(i.get("interaction_type") == "bookmark" for i in interactions)
        
        return CommunityPostInDB(**post)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting community post {post_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to get community post")


@router.put("/posts/{post_id}", response_model=CommunityPostInDB)
async def update_community_post(
    post_id: str,
    post_update: PostUpdateRequest,
    current_user: dict = Depends(get_current_user)
):
    """
    Update a community post.
    
    Requires: Post author, moderator, or admin
    """
    try:
        user_id = current_user.get("uid")
        user_role = current_user.get("role", "learner")
        
        # Get existing post
        post = await firestore_service.get_enhanced_community_post(post_id)
        if not post:
            raise HTTPException(status_code=404, detail="Post not found")
        
        # Check permissions
        if (post.get("author_id") != user_id and 
            user_role not in ["moderator", "admin"]):
            raise HTTPException(status_code=403, detail="Permission denied")
        
        # Update post
        update_data = {k: v for k, v in post_update.dict().items() if v is not None}
        update_data["updated_at"] = datetime.utcnow()
        
        # Add to edit history
        edit_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "editor_id": user_id,
            "changes": list(update_data.keys())
        }
        
        current_history = post.get("edit_history", [])
        current_history.append(edit_entry)
        update_data["edit_history"] = current_history
        
        await firestore_service.update_enhanced_community_post(post_id, update_data)
        
        # Return updated post
        updated_post = await firestore_service.get_enhanced_community_post(post_id)
        
        logger.info(f"Community post updated: {post_id} by user {user_id}")
        return CommunityPostInDB(**updated_post)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating community post {post_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to update community post")


# Media Upload

@router.post("/upload-media", response_model=EnhancedMediaUpload)
async def upload_media(
    file: UploadFile = File(...),
    media_type: Optional[str] = Form(None),
    context: Optional[str] = Form("community"),
    title: Optional[str] = Form(None),
    description: Optional[str] = Form(None),
    alt_text: Optional[str] = Form(None),
    tags: Optional[str] = Form(None),
    current_user: dict = Depends(get_current_user)
):
    """
    Upload media files for community posts.
    """
    try:
        user_id = current_user.get("uid")
        
        # Parse tags
        tag_list = [tag.strip() for tag in tags.split(",")] if tags else []
        
        # Upload to Cloudinary
        media_upload = await cloudinary_service.upload_community_media(
            file=file,
            post_id="temp",  # Temporary post ID for standalone uploads
            uploader_id=user_id,
            title=title,
            description=description,
            tags=tag_list
        )
        
        # Add alt_text if provided
        if alt_text:
            media_upload.alt_text = alt_text
        
        # Store media metadata in database
        await firestore_service.store_media_upload(media_upload.dict())
        
        logger.info(f"Media uploaded: {media_upload.id} by user {user_id}")
        return media_upload
        
    except Exception as e:
        logger.error(f"Error uploading media: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to upload media")


@router.post("/posts/{post_id}/media", response_model=EnhancedMediaUpload)
async def upload_post_media(
    post_id: str,
    file: UploadFile = File(...),
    title: Optional[str] = Form(None),
    description: Optional[str] = Form(None),
    alt_text: Optional[str] = Form(None),
    tags: Optional[str] = Form(None),
    current_user: dict = Depends(get_current_user)
):
    """
    Upload media for a community post.
    """
    try:
        user_id = current_user.get("uid")
        
        # Verify post exists and user has permission
        post = await firestore_service.get_enhanced_community_post(post_id)
        if not post:
            raise HTTPException(status_code=404, detail="Post not found")
        
        if post.get("author_id") != user_id:
            raise HTTPException(status_code=403, detail="Permission denied")
        
        # Parse tags
        tag_list = [tag.strip() for tag in tags.split(",")] if tags else []
        
        # Upload to Cloudinary
        media_upload = await cloudinary_service.upload_community_media(
            file=file,
            post_id=post_id,
            uploader_id=user_id,
            title=title,
            description=description,
            tags=tag_list
        )
        
        # Add alt_text if provided
        if alt_text:
            media_upload.alt_text = alt_text
        
        # Store media metadata in database
        await firestore_service.store_media_upload(media_upload.dict())
        
        # Update post's media_uploads list
        current_media = post.get("media_uploads", [])
        current_media.append(media_upload.id)
        await firestore_service.update_enhanced_community_post(post_id, {
            "media_uploads": current_media,
            "updated_at": datetime.utcnow()
        })
        
        logger.info(f"Media uploaded for post {post_id}: {media_upload.id}")
        return media_upload
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error uploading media for post {post_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to upload media")


# User Interactions

@router.post("/posts/{post_id}/interactions")
async def create_post_interaction(
    post_id: str,
    interaction_type: InteractionType,
    current_user: dict = Depends(get_current_user)
):
    """
    Create or update user interaction with a post (like, bookmark, etc.).
    """
    try:
        user_id = current_user.get("uid")
        
        # Verify post exists
        post = await firestore_service.get_enhanced_community_post(post_id)
        if not post:
            raise HTTPException(status_code=404, detail="Post not found")
        
        # Create interaction
        interaction = UserInteraction(
            id=f"{user_id}_{post_id}_{interaction_type.value}",
            user_id=user_id,
            target_id=post_id,
            target_type="post",
            interaction_type=interaction_type,
            timestamp=datetime.utcnow()
        )
        
        # Store interaction
        await firestore_service.create_user_interaction(interaction.dict())
        
        # Update post counts
        if interaction_type == InteractionType.LIKE:
            await firestore_service.increment_post_likes(post_id)
        elif interaction_type == InteractionType.SHARE:
            await firestore_service.increment_post_shares(post_id)
        elif interaction_type == InteractionType.BOOKMARK:
            await firestore_service.increment_post_bookmarks(post_id)
        
        return {"success": True, "message": f"Interaction {interaction_type.value} recorded"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating interaction for post {post_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to record interaction")


@router.delete("/posts/{post_id}/interactions/{interaction_type}")
async def remove_post_interaction(
    post_id: str,
    interaction_type: InteractionType,
    current_user: dict = Depends(get_current_user)
):
    """
    Remove user interaction with a post.
    """
    try:
        user_id = current_user.get("uid")
        
        # Remove interaction
        interaction_id = f"{user_id}_{post_id}_{interaction_type.value}"
        await firestore_service.remove_user_interaction(interaction_id)
        
        # Update post counts
        if interaction_type == InteractionType.LIKE:
            await firestore_service.decrement_post_likes(post_id)
        elif interaction_type == InteractionType.SHARE:
            await firestore_service.decrement_post_shares(post_id)
        elif interaction_type == InteractionType.BOOKMARK:
            await firestore_service.decrement_post_bookmarks(post_id)
        
        return {"success": True, "message": f"Interaction {interaction_type.value} removed"}
        
    except Exception as e:
        logger.error(f"Error removing interaction for post {post_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to remove interaction")


# Comments

@router.post("/posts/{post_id}/comments", response_model=PostComment)
async def create_comment(
    post_id: str,
    content: str = Form(...),
    parent_comment_id: Optional[str] = Form(None),
    media_files: List[UploadFile] = File(None),
    current_user: dict = Depends(get_current_user)
):
    """
    Create a comment on a post.
    """
    try:
        user_id = current_user.get("uid")
        
        # Verify post exists and allows comments
        post = await firestore_service.get_enhanced_community_post(post_id)
        if not post:
            raise HTTPException(status_code=404, detail="Post not found")
        
        if not post.get("allow_comments", True):
            raise HTTPException(status_code=403, detail="Comments not allowed on this post")
        
        # Determine thread level
        thread_level = 0
        if parent_comment_id:
            parent_comment = await firestore_service.get_post_comment(parent_comment_id)
            if parent_comment:
                thread_level = min(parent_comment.get("thread_level", 0) + 1, 5)  # Max 5 levels
        
        # Upload media if provided
        media_uploads = []
        if media_files:
            for file in media_files:
                try:
                    media_upload = await cloudinary_service.upload_community_media(
                        file=file,
                        post_id=f"comment_{post_id}",
                        uploader_id=user_id
                    )
                    media_uploads.append(media_upload.id)
                    await firestore_service.store_media_upload(media_upload.dict())
                except Exception as e:
                    logger.warning(f"Failed to upload media for comment: {str(e)}")
        
        # Create comment
        comment = PostComment(
            post_id=post_id,
            author_id=user_id,
            content=content,
            parent_comment_id=parent_comment_id,
            thread_level=thread_level,
            media_uploads=media_uploads,
            created_at=datetime.utcnow()
        )
        
        # Store comment
        comment_id = await firestore_service.create_post_comment(comment.dict())
        comment.id = comment_id
        
        # Update post comment count
        await firestore_service.increment_post_comments(post_id)
        
        # Update parent comment reply count if it's a reply
        if parent_comment_id:
            await firestore_service.increment_comment_replies(parent_comment_id)
        
        logger.info(f"Comment created on post {post_id}: {comment_id}")
        return comment
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating comment on post {post_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to create comment")


@router.get("/posts/{post_id}/comments", response_model=List[PostComment])
async def get_post_comments(
    post_id: str,
    sort_by: str = Query("recent", description="Sort order"),
    limit: int = Query(50, ge=1, le=200),
    offset: int = Query(0, ge=0),
    current_user: Optional[dict] = Depends(get_current_user)
):
    """
    Get comments for a post with threading support.
    """
    try:
        comments = await firestore_service.get_post_comments(
            post_id=post_id,
            sort_by=sort_by,
            limit=limit,
            offset=offset
        )
        
        return [PostComment(**comment) for comment in comments]
        
    except Exception as e:
        logger.error(f"Error getting comments for post {post_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to get comments")


# Fact-Checking

@router.post("/posts/{post_id}/fact-check", response_model=FactCheckRequest)
async def request_fact_check(
    post_id: str,
    priority: str = Query("normal", description="Priority level"),
    specific_claims: List[str] = Query(None, description="Specific claims to verify"),
    additional_context: Optional[str] = Query(None, description="Additional context"),
    current_user: dict = Depends(get_current_user)
):
    """
    Request fact-checking for a post.
    """
    try:
        user_id = current_user.get("uid")
        
        # Verify post exists
        post = await firestore_service.get_enhanced_community_post(post_id)
        if not post:
            raise HTTPException(status_code=404, detail="Post not found")
        
        # Create fact-check request
        fact_check_request = FactCheckRequest(
            requester_id=user_id,
            content_id=post_id,
            content_type="post",
            priority=priority,
            specific_claims=specific_claims or [],
            additional_context=additional_context,
            status=VerificationStatus.PENDING,
            created_at=datetime.utcnow()
        )
        
        # Store request
        request_id = await firestore_service.create_fact_check_request(fact_check_request.dict())
        fact_check_request.id = request_id
        
        # Update post status
        await firestore_service.update_enhanced_community_post(post_id, {
            "fact_check_status": VerificationStatus.PENDING,
            "updated_at": datetime.utcnow()
        })
        
        logger.info(f"Fact-check requested for post {post_id}: {request_id}")
        return fact_check_request
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error requesting fact-check for post {post_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to request fact-check")


# Reporting and Moderation

@router.post("/posts/{post_id}/report", response_model=CommunityReport)
async def report_post(
    post_id: str,
    report_type: str = Form(...),
    reason: str = Form(...),
    evidence_files: List[UploadFile] = File(None),
    current_user: dict = Depends(get_current_user)
):
    """
    Report a post for inappropriate content.
    """
    try:
        user_id = current_user.get("uid")
        
        # Verify post exists
        post = await firestore_service.get_enhanced_community_post(post_id)
        if not post:
            raise HTTPException(status_code=404, detail="Post not found")
        
        # Upload evidence files if provided
        evidence_urls = []
        if evidence_files:
            for file in evidence_files:
                try:
                    evidence_upload = await cloudinary_service.upload_report_evidence(
                        file=file,
                        report_id=f"report_{post_id}_{user_id}",
                        uploader_id=user_id
                    )
                    evidence_urls.append(evidence_upload.cloudinary_url)
                    await firestore_service.store_media_upload(evidence_upload.dict())
                except Exception as e:
                    logger.warning(f"Failed to upload evidence file: {str(e)}")
        
        # Create report
        report = CommunityReport(
            reporter_id=user_id,
            reported_content_id=post_id,
            reported_content_type="post",
            reported_user_id=post.get("author_id"),
            report_type=report_type,
            reason=reason,
            evidence_urls=evidence_urls,
            created_at=datetime.utcnow()
        )
        
        # Store report
        report_id = await firestore_service.create_community_report(report.dict())
        report.id = report_id
        
        # Update post report count
        await firestore_service.increment_post_reports(post_id)
        
        # Add to moderation queue if multiple reports
        report_count = await firestore_service.get_post_report_count(post_id)
        if report_count >= 3:  # Threshold for automatic review
            await firestore_service.add_to_moderation_queue(post_id, "post", "multiple_reports")
        
        logger.info(f"Post reported: {post_id} by user {user_id}")
        return report
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error reporting post {post_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to report post")


# Moderation Endpoints (Admin/Moderator only)

@router.get("/moderation/queue", response_model=List[CommunityModerationQueue])
async def get_moderation_queue(
    queue_type: Optional[str] = Query(None, description="Filter by queue type"),
    priority: Optional[int] = Query(None, description="Filter by priority"),
    limit: int = Query(50, ge=1, le=200),
    current_user: dict = Depends(require_roles(["moderator", "admin"]))
):
    """
    Get moderation queue items.
    
    Requires: Moderator or admin role
    """
    try:
        queue_items = await firestore_service.get_moderation_queue(
            queue_type=queue_type,
            priority=priority,
            limit=limit
        )
        
        return [CommunityModerationQueue(**item) for item in queue_items]
        
    except Exception as e:
        logger.error(f"Error getting moderation queue: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to get moderation queue")


@router.post("/moderation/{content_id}/action")
async def take_moderation_action(
    content_id: str,
    action: ModerationAction,
    reason: str = Form(...),
    notes: Optional[str] = Form(None),
    current_user: dict = Depends(require_roles(["moderator", "admin"]))
):
    """
    Take moderation action on content.
    
    Requires: Moderator or admin role
    """
    try:
        moderator_id = current_user.get("uid")
        
        # Record moderation action
        await firestore_service.record_moderation_action(
            content_id=content_id,
            content_type="post",
            action=action.value,
            reason=reason,
            moderator_id=moderator_id,
            notes=notes
        )
        
        # Apply action based on type
        if action == ModerationAction.REMOVE:
            await firestore_service.update_enhanced_community_post(content_id, {
                "status": PostStatus.REMOVED,
                "moderated_by": moderator_id,
                "moderation_reason": reason,
                "updated_at": datetime.utcnow()
            })
        elif action == ModerationAction.FLAG:
            await firestore_service.update_enhanced_community_post(content_id, {
                "status": PostStatus.FLAGGED,
                "moderated_by": moderator_id,
                "moderation_reason": reason,
                "updated_at": datetime.utcnow()
            })
        
        logger.info(f"Moderation action {action.value} taken on {content_id} by {moderator_id}")
        return {"success": True, "message": f"Action {action.value} applied successfully"}
        
    except Exception as e:
        logger.error(f"Error taking moderation action: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to take moderation action")


# Dashboard and Analytics

@router.get("/dashboard", response_model=CommunityDashboard)
async def get_community_dashboard(
    date_from: Optional[datetime] = Query(None, description="Start date for statistics"),
    date_to: Optional[datetime] = Query(None, description="End date for statistics"),
    current_user: Optional[dict] = Depends(get_current_user)
):
    """
    Get community dashboard with user and overall statistics.
    """
    try:
        user_id = current_user.get("uid") if current_user else None
        
        # Default date range (last 30 days)
        if not date_from:
            date_from = datetime.utcnow() - timedelta(days=30)
        if not date_to:
            date_to = datetime.utcnow()
        
        dashboard_data = await firestore_service.get_community_dashboard(
            user_id=user_id,
            date_from=date_from,
            date_to=date_to
        )
        
        return CommunityDashboard(**dashboard_data)
        
    except Exception as e:
        logger.error(f"Error getting community dashboard: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to get dashboard")


# Background Task Functions

async def initiate_fact_check(post_id: str, requester_id: str):
    """Background task to initiate automatic fact-checking."""
    try:
        # Get post content
        post = await firestore_service.get_enhanced_community_post(post_id)
        if not post:
            return
        
        # Use enhanced Gemini service for misinformation analysis
        analysis_request = {
            "content": post.get("content", ""),
            "content_type": "text",
            "user_language": "auto"
        }
        
        # This would integrate with the enhanced misinformation detection
        # analysis_result = await gemini_service.analyze_misinformation_enhanced(analysis_request)
        
        # For now, create a basic fact-check request
        fact_check_request = FactCheckRequest(
            requester_id="system",
            content_id=post_id,
            content_type="post",
            priority="normal",
            status=VerificationStatus.IN_PROGRESS,
            created_at=datetime.utcnow()
        )
        
        await firestore_service.create_fact_check_request(fact_check_request.dict())
        
    except Exception as e:
        logger.error(f"Error initiating fact-check for post {post_id}: {str(e)}")


async def analyze_educational_value(post_id: str):
    """Background task to analyze educational value of a post."""
    try:
        post = await firestore_service.get_enhanced_community_post(post_id)
        if not post:
            return
        
        # Analyze content for educational value
        # This could use AI to score educational content
        educational_score = 75.0  # Placeholder
        
        await firestore_service.update_enhanced_community_post(post_id, {
            "educational_value": educational_score,
            "updated_at": datetime.utcnow()
        })
        
    except Exception as e:
        logger.error(f"Error analyzing educational value for post {post_id}: {str(e)}")


async def analyze_misinformation_content(post_id: str, content: str):
    """Background task to analyze content for misinformation patterns."""
    try:
        # This would integrate with the enhanced misinformation detection system
        # For now, just flag for manual review
        await firestore_service.add_to_moderation_queue(
            content_id=post_id,
            content_type="post",
            queue_type="misinformation_check",
            priority=2  # High priority for misinformation
        )
        
    except Exception as e:
        logger.error(f"Error analyzing misinformation content for post {post_id}: {str(e)}")


# Search and Discovery

@router.post("/search", response_model=List[CommunityPostInDB])
async def search_posts(
    search_request: PostSearchRequest,
    current_user: Optional[dict] = Depends(get_current_user)
):
    """
    Advanced search for community posts.
    """
    try:
        user_id = current_user.get("uid") if current_user else None
        
        posts = await firestore_service.advanced_search_posts(search_request.dict(), user_id)
        
        return [CommunityPostInDB(**post) for post in posts]
        
    except Exception as e:
        logger.error(f"Error searching posts: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to search posts")


@router.get("/trending")
async def get_trending_content(
    timeframe: str = Query("24h", description="Timeframe for trending (1h, 24h, 7d)"),
    limit: int = Query(20, ge=1, le=100),
    current_user: Optional[dict] = Depends(get_current_user)
):
    """
    Get trending posts and topics.
    """
    try:
        trending_data = await firestore_service.get_trending_content(timeframe, limit)
        
        return trending_data
        
    except Exception as e:
        logger.error(f"Error getting trending content: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to get trending content")